diff --git a/core/lib/Drupal/Core/Entity/ContentEntityBase.php b/core/lib/Drupal/Core/Entity/ContentEntityBase.php
index 19ad14fca9..f5e9f5127c 100644
--- a/core/lib/Drupal/Core/Entity/ContentEntityBase.php
+++ b/core/lib/Drupal/Core/Entity/ContentEntityBase.php
@@ -176,6 +176,27 @@ abstract class ContentEntityBase extends EntityBase implements \IteratorAggregat
    */
   protected $enforceRevisionTranslationAffected = [];
 
+  /**
+   * The revision_parent revision metadata key.
+   *
+   * @var string
+   */
+  protected $revisionParentKey;
+
+  /**
+   * The revision_merge_parent revision metadata key.
+   *
+   * @var string
+   */
+  protected $revisionMergeParentKey;
+
+  /**
+   * Whether the parent revision IDs have been enforced.
+   *
+   * @var bool
+   */
+  protected $enforceRevisionParent = FALSE;
+
   /**
    * Local cache for fields to skip from the checking for translation changes.
    *
@@ -192,6 +213,8 @@ public function __construct(array $values, $entity_type, $bundle = FALSE, $trans
     $this->langcodeKey = $this->getEntityType()->getKey('langcode');
     $this->defaultLangcodeKey = $this->getEntityType()->getKey('default_langcode');
     $this->revisionTranslationAffectedKey = $this->getEntityType()->getKey('revision_translation_affected');
+    $this->revisionParentKey = $this->getEntityType()->getRevisionMetadataKeys(FALSE)['revision_parent'];
+    $this->revisionMergeParentKey = $this->getEntityType()->getRevisionMetadataKeys(FALSE)['revision_merge_parent'];
 
     foreach ($values as $key => $value) {
       // If the key matches an existing property set the value to the property
@@ -322,6 +345,50 @@ public function updateLoadedRevisionId() {
     return $this;
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function getParentRevisionId() {
+    if (!$this->getEntityType()->isRevisionable()) {
+      return NULL;
+    }
+
+    return $this->get($this->revisionParentKey)->target_revision_id;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getMergeParentRevisionId() {
+    if (!$this->getEntityType()->isRevisionable()) {
+      return NULL;
+    }
+
+    return $this->get($this->revisionMergeParentKey)->target_revision_id;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setParentRevisionId($revision_id) {
+    if ($this->getEntityType()->isRevisionable()) {
+      $this->get($this->revisionParentKey)->target_revision_id = $revision_id;
+    }
+
+    return $this;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setMergeParentRevisionId($revision_id) {
+    if ($this->getEntityType()->isRevisionable()) {
+      $this->get($this->revisionMergeParentKey)->target_revision_id = $revision_id;
+    }
+
+    return $this;
+  }
+
   /**
    * {@inheritdoc}
    */
@@ -447,6 +514,14 @@ public function preSave(EntityStorageInterface $storage) {
       $this->validated = FALSE;
     }
 
+    // Set the parent revision ID automatically when we create a new revision.
+    if ($this->isNewRevision() && !$this->enforceRevisionParent) {
+      // By default, the parent revision is the active revision of the branch.
+      // @todo Use the active revision ID once it is available.
+      //   @see https://www.drupal.org/project/drupal/issues/3023194
+      $this->setParentRevisionId($storage->getLatestRevisionId($this->id()));
+    }
+
     parent::preSave($storage);
   }
 
@@ -479,6 +554,9 @@ public function postSave(EntityStorageInterface $storage, $update = TRUE) {
 
     // Reset the enforcement of the revision translation affected flag.
     $this->enforceRevisionTranslationAffected = [];
+
+    // Reset the enforcement of the revision parent value.
+    $this->enforceRevisionParent = FALSE;
   }
 
   /**
@@ -838,6 +916,11 @@ public function onChange($name) {
         // its value.
         $this->setRevisionTranslationAffectedEnforced(TRUE);
         break;
+
+      case $this->revisionParentKey:
+        // If the revision parent is being set then enforce its value.
+        $this->enforceRevisionParent = TRUE;
+        break;
     }
   }
 
@@ -922,6 +1005,7 @@ protected function initializeTranslation($langcode) {
     $translation->loadedRevisionId = &$this->loadedRevisionId;
     $translation->isDefaultRevision = &$this->isDefaultRevision;
     $translation->enforceRevisionTranslationAffected = &$this->enforceRevisionTranslationAffected;
+    $translation->enforceRevisionParent = &$this->enforceRevisionParent;
     $translation->isSyncing = &$this->isSyncing;
 
     return $translation;
@@ -1192,8 +1276,8 @@ public function __clone() {
     // Ensure that the following properties are actually cloned by
     // overwriting the original references with ones pointing to copies of
     // them: enforceIsNew, newRevision, loadedRevisionId, fields, entityKeys,
-    // translatableEntityKeys, values, isDefaultRevision and
-    // enforceRevisionTranslationAffected.
+    // translatableEntityKeys, values, isDefaultRevision,
+    // enforceRevisionTranslationAffected and enforceParentRevision.
     $enforce_is_new = $this->enforceIsNew;
     $this->enforceIsNew = &$enforce_is_new;
 
@@ -1221,6 +1305,9 @@ public function __clone() {
     $is_revision_translation_affected_enforced = $this->enforceRevisionTranslationAffected;
     $this->enforceRevisionTranslationAffected = &$is_revision_translation_affected_enforced;
 
+    $is_parent_revision_enforced = $this->enforceRevisionParent;
+    $this->enforceRevisionParent = &$is_parent_revision_enforced;
+
     $is_syncing = $this->isSyncing;
     $this->isSyncing = &$is_syncing;
 
diff --git a/core/lib/Drupal/Core/Entity/ContentEntityStorageBase.php b/core/lib/Drupal/Core/Entity/ContentEntityStorageBase.php
index 3ec93063ad..882a53eb64 100644
--- a/core/lib/Drupal/Core/Entity/ContentEntityStorageBase.php
+++ b/core/lib/Drupal/Core/Entity/ContentEntityStorageBase.php
@@ -723,6 +723,7 @@ protected function doPostSave(EntityInterface $entity, $update) {
     if ($this->entityType->isRevisionable()) {
       $entity->updateLoadedRevisionId();
       $entity->setNewRevision(FALSE);
+      unset($this->latestRevisionIds[$entity->id()]);
     }
   }
 
diff --git a/core/lib/Drupal/Core/Entity/ContentEntityType.php b/core/lib/Drupal/Core/Entity/ContentEntityType.php
index 66b1a06a8a..932bc21b63 100644
--- a/core/lib/Drupal/Core/Entity/ContentEntityType.php
+++ b/core/lib/Drupal/Core/Entity/ContentEntityType.php
@@ -37,6 +37,12 @@ public function __construct($definition) {
       'view_builder' => 'Drupal\Core\Entity\EntityViewBuilder',
     ];
 
+    if ($this->isRevisionable()) {
+      $this->handlers += [
+        'revision_tree' => 'Drupal\Core\Entity\Sql\SqlRevisionTreeHandler',
+      ];
+    }
+
     // Only new instances should provide the required revision metadata keys.
     // The cached instances should return only what already has been stored
     // under the property $revision_metadata_keys. The BC layer in
@@ -47,6 +53,12 @@ public function __construct($definition) {
     if (!isset($this->revision_metadata_keys['revision_default'])) {
       $this->requiredRevisionMetadataKeys['revision_default'] = 'revision_default';
     }
+    if (!isset($this->revision_metadata_keys['revision_parent'])) {
+      $this->requiredRevisionMetadataKeys['revision_parent'] = 'revision_parent';
+    }
+    if (!isset($this->revision_metadata_keys['revision_merge_parent'])) {
+      $this->requiredRevisionMetadataKeys['revision_merge_parent'] = 'revision_merge_parent';
+    }
 
     // Add the required revision metadata fields here instead in the getter
     // method, so that they are serialized as part of the object even if the
diff --git a/core/lib/Drupal/Core/Entity/EntityFieldManager.php b/core/lib/Drupal/Core/Entity/EntityFieldManager.php
index ef6ac0e41a..f17e938e56 100644
--- a/core/lib/Drupal/Core/Entity/EntityFieldManager.php
+++ b/core/lib/Drupal/Core/Entity/EntityFieldManager.php
@@ -232,6 +232,22 @@ protected function buildBaseFieldDefinitions($entity_type_id) {
 
     // Make sure that revisionable entity types are correctly defined.
     if ($entity_type->isRevisionable()) {
+      $field_name = $entity_type->getRevisionMetadataKeys(FALSE)['revision_parent'];
+      $base_field_definitions[$field_name] = BaseFieldDefinition::create('revision_reference')
+        ->setLabel($this->t('Revision parent'))
+        ->setDescription($this->t('Indicates the parent revision ID.'))
+        ->setInternal(TRUE)
+        ->setTranslatable(FALSE)
+        ->setRevisionable(TRUE);
+
+      $field_name = $entity_type->getRevisionMetadataKeys(FALSE)['revision_merge_parent'];
+      $base_field_definitions[$field_name] = BaseFieldDefinition::create('revision_reference')
+        ->setLabel($this->t('Revision merge parent'))
+        ->setDescription($this->t('Indicates the merge parent revision ID.'))
+        ->setInternal(TRUE)
+        ->setTranslatable(FALSE)
+        ->setRevisionable(TRUE);
+
       // Disable the BC layer to prevent a recursion, this only needs the
       // revision_default key that is always set.
       $field_name = $entity_type->getRevisionMetadataKeys(FALSE)['revision_default'];
diff --git a/core/lib/Drupal/Core/Entity/EntityType.php b/core/lib/Drupal/Core/Entity/EntityType.php
index 71aea12b80..588a9c578a 100644
--- a/core/lib/Drupal/Core/Entity/EntityType.php
+++ b/core/lib/Drupal/Core/Entity/EntityType.php
@@ -323,6 +323,11 @@ public function __construct($definition) {
       $this->checkStorageClass($this->handlers['storage']);
     }
 
+    // Automatically add the "ValidRevisionParent" constraint if the entity type
+    // is revisionable.
+    if ($this->isRevisionable()) {
+      $this->addConstraint('ValidRevisionParent', []);
+    }
     // Automatically add the "EntityChanged" constraint if the entity type
     // tracks the changed time.
     if ($this->entityClassImplements(EntityChangedInterface::class)) {
diff --git a/core/lib/Drupal/Core/Entity/RevisionableInterface.php b/core/lib/Drupal/Core/Entity/RevisionableInterface.php
index d0feb230ff..8049a6a539 100644
--- a/core/lib/Drupal/Core/Entity/RevisionableInterface.php
+++ b/core/lib/Drupal/Core/Entity/RevisionableInterface.php
@@ -63,6 +63,42 @@ public function getRevisionId();
    */
   public function getLoadedRevisionId();
 
+  /**
+   * Gets the parent revisions ID.
+   *
+   * @return int|string
+   *   The parent revision ID.
+   */
+  public function getParentRevisionId();
+
+  /**
+   * Gets the merge parent revisions ID.
+   *
+   * @return int|string
+   *   The merge parent revision ID.
+   */
+  public function getMergeParentRevisionId();
+
+  /**
+   * Sets the parent revision ID.
+   *
+   * @param int|string $revision_id
+   *   The ID of the parent revision.
+   *
+   * @return $this
+   */
+  public function setParentRevisionId($revision_id);
+
+  /**
+   * Sets the merge parent revision ID.
+   *
+   * @param int|string $revision_id
+   *   The ID of the merge parent revision.
+   *
+   * @return $this
+   */
+  public function setMergeParentRevisionId($revision_id);
+
   /**
    * Updates the loaded Revision ID with the revision ID.
    *
diff --git a/core/lib/Drupal/Core/Entity/Sql/SqlContentEntityStorageSchemaConverter.php b/core/lib/Drupal/Core/Entity/Sql/SqlContentEntityStorageSchemaConverter.php
index 037c9f91fb..258a4c8dc7 100644
--- a/core/lib/Drupal/Core/Entity/Sql/SqlContentEntityStorageSchemaConverter.php
+++ b/core/lib/Drupal/Core/Entity/Sql/SqlContentEntityStorageSchemaConverter.php
@@ -120,6 +120,30 @@ public function convertToRevisionable(array &$sandbox, array $fields_to_update =
       ->setTranslatable(FALSE)
       ->setRevisionable(TRUE);
 
+    // Add the 'revision_parent' field.
+    $field_name = $entity_type->getRevisionMetadataKey('revision_parent');
+    $field_storage_definitions[$field_name] = BaseFieldDefinition::create('revision_reference')
+      ->setName($field_name)
+      ->setTargetEntityTypeId($entity_type->id())
+      ->setTargetBundle(NULL)
+      ->setLabel(t('Revision parent'))
+      ->setDescription(t('Indicates the parent revision ID.'))
+      ->setInternal(TRUE)
+      ->setTranslatable(FALSE)
+      ->setRevisionable(TRUE);
+
+    // Add the 'revision_merge_parent' field.
+    $field_name = $entity_type->getRevisionMetadataKey('revision_merge_parent');
+    $field_storage_definitions[$field_name] = BaseFieldDefinition::create('revision_reference')
+      ->setName($field_name)
+      ->setTargetEntityTypeId($entity_type->id())
+      ->setTargetBundle(NULL)
+      ->setLabel(t('Revision merge parent'))
+      ->setDescription(t('Indicates the merge parent revision ID.'))
+      ->setInternal(TRUE)
+      ->setTranslatable(FALSE)
+      ->setRevisionable(TRUE);
+
     // Add the 'revision_translation_affected' field if needed.
     if ($entity_type->isTranslatable()) {
       $field_name = $entity_type->getKey('revision_translation_affected');
diff --git a/core/modules/field/tests/src/Kernel/FieldTypePluginManagerTest.php b/core/modules/field/tests/src/Kernel/FieldTypePluginManagerTest.php
index c40229fe7a..62ab9700ea 100644
--- a/core/modules/field/tests/src/Kernel/FieldTypePluginManagerTest.php
+++ b/core/modules/field/tests/src/Kernel/FieldTypePluginManagerTest.php
@@ -99,6 +99,7 @@ public function testMainProperty() {
       $class = $definition['class'];
       $property = $class::mainPropertyName();
       $storage_definition = BaseFieldDefinition::create($plugin_id);
+      $storage_definition->setTargetEntityTypeId('entity_test_mulrev');
       $property_definitions = $class::propertyDefinitions($storage_definition);
       $properties = implode(', ', array_keys($property_definitions));
       if (!empty($property_definitions)) {
diff --git a/core/modules/menu_link_content/menu_link_content.post_update.php b/core/modules/menu_link_content/menu_link_content.post_update.php
index 0c0a64388e..5a238d5bac 100644
--- a/core/modules/menu_link_content/menu_link_content.post_update.php
+++ b/core/modules/menu_link_content/menu_link_content.post_update.php
@@ -12,6 +12,10 @@
  * Update custom menu links to be revisionable.
  */
 function menu_link_content_post_update_make_menu_link_content_revisionable(&$sandbox) {
+  // Clear the field type definition plugin cache so the new
+  // 'revision_reference' field type is available during the update process.
+  \Drupal::service('plugin.manager.field.field_type')->clearCachedDefinitions();
+
   $definition_update_manager = \Drupal::entityDefinitionUpdateManager();
   /** @var \Drupal\Core\Entity\EntityLastInstalledSchemaRepositoryInterface $last_installed_schema_repository */
   $last_installed_schema_repository = \Drupal::service('entity.last_installed_schema.repository');
@@ -28,6 +32,8 @@ function menu_link_content_post_update_make_menu_link_content_revisionable(&$san
   $entity_type->set('revision_data_table', 'menu_link_content_field_revision');
   $revision_metadata_keys = [
     'revision_default' => 'revision_default',
+    'revision_parent' => 'revision_parent',
+    'revision_merge_parent' => 'revision_merge_parent',
     'revision_user' => 'revision_user',
     'revision_created' => 'revision_created',
     'revision_log_message' => 'revision_log_message',
@@ -73,6 +79,26 @@ function menu_link_content_post_update_make_menu_link_content_revisionable(&$san
     ->setRevisionable(TRUE)
     ->setTranslatable(TRUE);
 
+  $field_storage_definitions['revision_parent'] = BaseFieldDefinition::create('revision_reference')
+    ->setName('revision_parent')
+    ->setTargetEntityTypeId('menu_link_content')
+    ->setTargetBundle(NULL)
+    ->setLabel(new TranslatableMarkup('Revision parent'))
+    ->setDescription(new TranslatableMarkup('Indicates the parent revision ID.'))
+    ->setInternal(TRUE)
+    ->setTranslatable(FALSE)
+    ->setRevisionable(TRUE);
+
+  $field_storage_definitions['revision_merge_parent'] = BaseFieldDefinition::create('revision_reference')
+    ->setName('revision_merge_parent')
+    ->setTargetEntityTypeId('menu_link_content')
+    ->setTargetBundle(NULL)
+    ->setLabel(new TranslatableMarkup('Revision merge parent'))
+    ->setDescription(new TranslatableMarkup('Indicates the merge parent revision ID.'))
+    ->setInternal(TRUE)
+    ->setTranslatable(FALSE)
+    ->setRevisionable(TRUE);
+
   $field_storage_definitions['revision_created'] = BaseFieldDefinition::create('created')
     ->setName('revision_created')
     ->setTargetEntityTypeId('menu_link_content')
diff --git a/core/modules/system/system.install b/core/modules/system/system.install
index 5a548735aa..c5c03f8c55 100644
--- a/core/modules/system/system.install
+++ b/core/modules/system/system.install
@@ -18,6 +18,7 @@
 use Drupal\Core\Entity\ContentEntityTypeInterface;
 use Drupal\Core\Entity\EntityTypeInterface;
 use Drupal\Core\Entity\FieldableEntityInterface;
+use Drupal\Core\Entity\Sql\SqlEntityStorageInterface;
 use Drupal\Core\DrupalKernel;
 use Drupal\Core\Extension\Extension;
 use Drupal\Core\Field\BaseFieldDefinition;
@@ -2292,3 +2293,170 @@ function system_update_8702() {
   }
   \Drupal::entityTypeManager()->useCaches(TRUE);
 }
+
+/**
+ * Add the 'revision_parent' field to all relevant entity types.
+ */
+function system_update_8703() {
+  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
+
+  // Get a list of revisionable entity types.
+  /** @var \Drupal\Core\Entity\EntityTypeInterface[] $definitions */
+  $definitions = array_filter($entity_definition_update_manager->getEntityTypes(), function (EntityTypeInterface $entity_type) {
+    return $entity_type->isRevisionable();
+  });
+
+  // Check if a field named 'revision_parent' already exists.
+  foreach ($definitions as $entity_type_id => $entity_type) {
+    $revision_metadata_keys = $entity_type->get('revision_metadata_keys');
+
+    if (!isset($revision_metadata_keys['revision_parent']) && $entity_definition_update_manager->getFieldStorageDefinition('revision_parent', $entity_type_id)) {
+      throw new \RuntimeException("An existing 'revision_parent' field was found for the '$entity_type_id' entity type. Set the 'revision_parent' revision metadata key to use a different field name and run this update function again.");
+    }
+    if (!isset($revision_metadata_keys['revision_merge_parent']) && $entity_definition_update_manager->getFieldStorageDefinition('revision_merge_parent', $entity_type_id)) {
+      throw new \RuntimeException("An existing 'revision_merge_parent' field was found for the '$entity_type_id' entity type. Set the 'revision_merge_parent' revision metadata key to use a different field name and run this update function again.");
+    }
+  }
+
+  // Clear the field type definition plugin cache so the new
+  // 'revision_reference' field type is available during the update process.
+  \Drupal::service('plugin.manager.field.field_type')->clearCachedDefinitions();
+
+  // Install the 'revision_parent' and 'revision_merge_parent' fields.
+  foreach ($definitions as $entity_type_id => $entity_type) {
+    $revision_metadata_keys = $entity_type->get('revision_metadata_keys');
+
+    foreach (['revision_parent', 'revision_merge_parent'] as $key) {
+      if (!isset($revision_metadata_keys[$key])) {
+        $field_name = $key;
+
+        // Update the property holding the required revision metadata keys that is
+        // used to provide the BC layer for them.
+        // @see \Drupal\Core\Entity\ContentEntityType::getRevisionMetadataKeys().
+        $required_revision_metadata_keys = $entity_type->get('requiredRevisionMetadataKeys');
+        $required_revision_metadata_keys[$key] = $field_name;
+        $entity_type->set('requiredRevisionMetadataKeys', $required_revision_metadata_keys);
+
+        // Update the revision metadata keys to add the new "revision_parent" key.
+        $revision_metadata_keys[$key] = $field_name;
+        $entity_type->set('revision_metadata_keys', $revision_metadata_keys);
+
+        $entity_definition_update_manager->updateEntityType($entity_type);
+      }
+    }
+
+    $storage_definition = BaseFieldDefinition::create('revision_reference')
+      ->setLabel(t('Revision parent'))
+      ->setDescription(t('Indicates the parent revision ID.'))
+      ->setInternal(TRUE)
+      ->setTranslatable(FALSE)
+      ->setRevisionable(TRUE);
+
+    $entity_definition_update_manager
+      ->installFieldStorageDefinition($revision_metadata_keys['revision_parent'], $entity_type_id, $entity_type->getProvider(), $storage_definition);
+
+    $storage_definition = BaseFieldDefinition::create('revision_reference')
+      ->setLabel(t('Revision merge parent'))
+      ->setDescription(t('Indicates the merge parent revision ID.'))
+      ->setInternal(TRUE)
+      ->setTranslatable(FALSE)
+      ->setRevisionable(TRUE);
+
+    $entity_definition_update_manager
+      ->installFieldStorageDefinition($revision_metadata_keys['revision_merge_parent'], $entity_type_id, $entity_type->getProvider(), $storage_definition);
+  }
+
+  return t('The revision parent field has been added.');
+}
+
+/**
+ * Fill values for the 'revision_parent' field.
+ */
+function system_update_8704(&$sandbox = NULL) {
+  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
+  $entity_type_manager = \Drupal::entityTypeManager();
+  $database = \Drupal::database();
+
+  if (!isset($sandbox['current'])) {
+    // This must be the first run. Initialize the sandbox.
+    $sandbox['current'] = 0;
+
+    // Get a list of revisionable entity types that use the default SQL storage.
+    /** @var \Drupal\Core\Entity\EntityTypeInterface[] $definitions */
+    $definitions = array_filter($entity_definition_update_manager->getEntityTypes(), function (EntityTypeInterface $entity_type) {
+      return $entity_type->isRevisionable() && is_a($entity_type->getStorageClass(), SqlEntityStorageInterface::class, TRUE);
+    });
+
+    $sandbox['entity_type_ids'] = array_keys($definitions);
+    $sandbox['max'] = count($sandbox['entity_type_ids']);
+  }
+
+  $current_entity_type_key = $sandbox['current'];
+  for ($i = $current_entity_type_key; ($i < $current_entity_type_key + 1) && ($i < $sandbox['max']); $i++) {
+    $entity_type_id = $sandbox['entity_type_ids'][$i];
+    /** @var \Drupal\Core\Entity\ContentEntityType $entity_type */
+    $entity_type = $entity_definition_update_manager->getEntityType($entity_type_id);
+    $id_field_storage_definition = $entity_definition_update_manager->getFieldStorageDefinition($entity_type->getKey('id'), $entity_type_id);
+    $revision_id_field_storage_definition = $entity_definition_update_manager->getFieldStorageDefinition($entity_type->getKey('revision'), $entity_type_id);
+    $parent_revision_field_storage_definition = $entity_definition_update_manager->getFieldStorageDefinition($entity_type->get('revision_metadata_keys')['revision_parent'], $entity_type_id);
+
+    /** @var \Drupal\Core\Entity\Sql\SqlEntityStorageInterface $storage */
+    $storage = $entity_type_manager->createHandlerInstance($entity_type->getStorageClass(), $entity_type);
+
+    /** @var \Drupal\Core\Entity\Sql\DefaultTableMapping $table_mapping */
+    $table_mapping = $storage->getTableMapping();
+    $revision_table = $table_mapping->getRevisionTable();
+
+    $id_column = $table_mapping->getFieldColumnName($id_field_storage_definition, $id_field_storage_definition->getMainPropertyName());
+    $revision_id_column = $table_mapping->getFieldColumnName($revision_id_field_storage_definition, $revision_id_field_storage_definition->getMainPropertyName());
+    $revision_parent_column = $table_mapping->getFieldColumnName($parent_revision_field_storage_definition, $parent_revision_field_storage_definition->getMainPropertyName());
+
+    // This must be the first run for this entity type. Initialize the
+    // sub-sandbox for it.
+    if (!isset($sandbox[$entity_type_id])) {
+      $sandbox[$entity_type_id]['current_id'] = -1;
+    }
+
+    // The default step size used for batching entity saves is very low because
+    // storing an entity involves at least 4 table writes for the shared tables
+    // and an unknown number of writes for dedicated field tables. This update
+    // function only does a select and update so the limit can be much higher.
+    $step_size = Settings::get('entity_update_batch_size', 50) * 10;
+
+    // Collect the revision IDs to process.
+    $revisions = $database->select($revision_table, 't')
+      ->condition("t.$revision_id_column", $sandbox[$entity_type_id]['current_id'], '>')
+      ->isNull("t.$revision_parent_column")
+      ->fields('t', [$revision_id_column, $id_column])
+      ->orderBy($revision_id_column, 'ASC')
+      ->range(0, $step_size)
+      ->execute()
+      ->fetchAllKeyed();
+
+    foreach ($revisions as $revision_id => $entity_id) {
+      $parent_revision_id = $database->select($revision_table, 't')
+        ->fields('t', [$revision_id_column])
+        ->condition($revision_id_column, $revision_id, '<')
+        ->condition($id_column, $entity_id, '=')
+        ->orderBy($revision_id_column, 'DESC')
+        ->range(0, 1)
+        ->execute()
+        ->fetchField() ?: NULL;
+
+      if ($parent_revision_id) {
+        $database->update($revision_table)
+          ->fields([$revision_parent_column => $parent_revision_id])
+          ->condition($revision_id_column, $revision_id, '=')
+          ->execute();
+      }
+
+      $sandbox[$entity_type_id]['current_id'] = $revision_id;
+    }
+
+    if (count($revisions) < $step_size) {
+      $sandbox['current']++;
+    }
+  }
+
+  $sandbox['#finished'] = $sandbox['current'] == $sandbox['max'];
+}
diff --git a/core/modules/system/tests/modules/entity_test/src/Entity/EntityTestNoBundle.php b/core/modules/system/tests/modules/entity_test/src/Entity/EntityTestNoBundle.php
index 0369a64abc..4ce76d9c9c 100644
--- a/core/modules/system/tests/modules/entity_test/src/Entity/EntityTestNoBundle.php
+++ b/core/modules/system/tests/modules/entity_test/src/Entity/EntityTestNoBundle.php
@@ -12,6 +12,8 @@
  *   handlers = {
  *     "views_data" = "Drupal\views\EntityViewsData"
  *   },
+ *   base_table = "entity_test_no_bundle",
+ *   revision_table = "entity_test_no_bundle_revision",
  *   entity_keys = {
  *     "id" = "id",
  *     "revision" = "revision_id",
diff --git a/core/modules/system/tests/src/Functional/Entity/Update/MoveRevisionMetadataFieldsUpdateTest.php b/core/modules/system/tests/src/Functional/Entity/Update/MoveRevisionMetadataFieldsUpdateTest.php
index 2334f33735..a6cec6c4eb 100644
--- a/core/modules/system/tests/src/Functional/Entity/Update/MoveRevisionMetadataFieldsUpdateTest.php
+++ b/core/modules/system/tests/src/Functional/Entity/Update/MoveRevisionMetadataFieldsUpdateTest.php
@@ -38,26 +38,29 @@ public function setDatabaseDumpFiles() {
   public function testSystemUpdate8400() {
     $this->runUpdates();
 
+    $database_schema = \Drupal::database()->schema();
     foreach (['entity_test_revlog', 'entity_test_mul_revlog'] as $entity_type_id) {
       /** @var \Drupal\Core\Entity\ContentEntityStorageInterface $storage */
       $storage = \Drupal::entityTypeManager()->getStorage($entity_type_id);
       /** @var \Drupal\Core\Entity\ContentEntityTypeInterface $entity_type */
       $entity_type = $storage->getEntityType();
+      /** @var \Drupal\Core\Entity\Sql\TableMappingInterface $table_mapping */
+      $table_mapping = $storage->getTableMapping();
       $revision_metadata_field_names = $entity_type->getRevisionMetadataKeys();
 
-      $database_schema = \Drupal::database()->schema();
-
       // Test that the revision metadata fields are present only in the
       // revision table.
       foreach ($revision_metadata_field_names as $revision_metadata_field_name) {
+        $column_names = $table_mapping->getColumnNames($revision_metadata_field_name);
+        $main_property_column = reset($column_names);
         if ($entity_type->isTranslatable()) {
-          $this->assertFalse($database_schema->fieldExists($entity_type->getDataTable(), $revision_metadata_field_name));
-          $this->assertFalse($database_schema->fieldExists($entity_type->getRevisionDataTable(), $revision_metadata_field_name));
+          $this->assertFalse($database_schema->fieldExists($entity_type->getDataTable(), $main_property_column));
+          $this->assertFalse($database_schema->fieldExists($entity_type->getRevisionDataTable(), $main_property_column));
         }
         else {
-          $this->assertFalse($database_schema->fieldExists($entity_type->getBaseTable(), $revision_metadata_field_name));
+          $this->assertFalse($database_schema->fieldExists($entity_type->getBaseTable(), $main_property_column));
         }
-        $this->assertTrue($database_schema->fieldExists($entity_type->getRevisionTable(), $revision_metadata_field_name));
+        $this->assertTrue($database_schema->fieldExists($entity_type->getRevisionTable(), $main_property_column));
       }
 
       // Test that the revision metadata values have been transferred correctly
@@ -135,12 +138,14 @@ public function testAddingRequiredRevisionMetadataKeys() {
       ];
     $this->assertEquals($required_revision_metadata_keys_with_bc, $entity_type->getRevisionMetadataKeys(TRUE));
 
-    // Ensure that newly instantiated entity types will return the two required
+    // Ensure that newly instantiated entity types will return the required
     // revision metadata keys.
     $entity_type = new TestRevisionMetadataBcLayerEntityType(['id' => 'test']);
     $required_revision_metadata_keys = [
       'revision_default' => 'revision_default',
       'second_required_key' => 'second_required_key',
+      'revision_parent' => 'revision_parent',
+      'revision_merge_parent' => 'revision_merge_parent',
     ];
     $this->assertEquals($required_revision_metadata_keys, $entity_type->getRevisionMetadataKeys(FALSE));
 
@@ -164,6 +169,8 @@ public function testAddingRequiredRevisionMetadataKeys() {
     $entity_type = $entity_type_manager->getDefinition('entity_test_mul_revlog');
     $revision_metadata_keys = [
       'revision_default' => 'revision_default',
+      'revision_parent' => 'revision_parent',
+      'revision_merge_parent' => 'revision_merge_parent',
     ];
     $this->assertEquals($revision_metadata_keys, $entity_type->getRevisionMetadataKeys(FALSE));
     $revision_metadata_keys = [
@@ -171,6 +178,8 @@ public function testAddingRequiredRevisionMetadataKeys() {
       'revision_created' => 'revision_created',
       'revision_log_message' => 'revision_log_message',
       'revision_default' => 'revision_default',
+      'revision_parent' => 'revision_parent',
+      'revision_merge_parent' => 'revision_merge_parent',
     ];
     $this->assertEquals($revision_metadata_keys, $entity_type->getRevisionMetadataKeys(TRUE));
 
@@ -185,6 +194,8 @@ public function testAddingRequiredRevisionMetadataKeys() {
     $entity_type = new ContentEntityType($definition);
     $revision_metadata_keys = [
       'revision_default' => 'revision_default',
+      'revision_parent' => 'revision_parent',
+      'revision_merge_parent' => 'revision_merge_parent',
     ];
     $this->assertEquals($revision_metadata_keys, $entity_type->getRevisionMetadataKeys(TRUE));
 
@@ -196,6 +207,8 @@ public function testAddingRequiredRevisionMetadataKeys() {
     $entity_type = new ContentEntityType($definition);
     $revision_metadata_keys = [
       'revision_default' => 'revision_default',
+      'revision_parent' => 'revision_parent',
+      'revision_merge_parent' => 'revision_merge_parent',
       'revision_user' => 'revision_user',
       'revision_created' => 'revision_created',
       'revision_log_message' => 'revision_log_message',
diff --git a/core/modules/taxonomy/taxonomy.post_update.php b/core/modules/taxonomy/taxonomy.post_update.php
index bbeb74f3ff..888a1012fb 100644
--- a/core/modules/taxonomy/taxonomy.post_update.php
+++ b/core/modules/taxonomy/taxonomy.post_update.php
@@ -146,6 +146,10 @@ function taxonomy_post_update_remove_hierarchy_from_vocabularies(&$sandbox = NUL
  * Update taxonomy terms to be revisionable.
  */
 function taxonomy_post_update_make_taxonomy_term_revisionable(&$sandbox) {
+  // Clear the field type definition plugin cache so the new
+  // 'revision_reference' field type is available during the update process.
+  \Drupal::service('plugin.manager.field.field_type')->clearCachedDefinitions();
+
   $definition_update_manager = \Drupal::entityDefinitionUpdateManager();
   /** @var \Drupal\Core\Entity\EntityLastInstalledSchemaRepositoryInterface $last_installed_schema_repository */
   $last_installed_schema_repository = \Drupal::service('entity.last_installed_schema.repository');
@@ -162,6 +166,8 @@ function taxonomy_post_update_make_taxonomy_term_revisionable(&$sandbox) {
   $entity_type->set('revision_data_table', 'taxonomy_term_field_revision');
   $revision_metadata_keys = [
     'revision_default' => 'revision_default',
+    'revision_parent' => 'revision_parent',
+    'revision_merge_parent' => 'revision_merge_parent',
     'revision_user' => 'revision_user',
     'revision_created' => 'revision_created',
     'revision_log_message' => 'revision_log_message',
@@ -204,6 +210,26 @@ function taxonomy_post_update_make_taxonomy_term_revisionable(&$sandbox) {
     ->setRevisionable(TRUE)
     ->setTranslatable(TRUE);
 
+  $field_storage_definitions['revision_parent'] = BaseFieldDefinition::create('revision_reference')
+    ->setName('revision_parent')
+    ->setTargetEntityTypeId('taxonomy_term')
+    ->setTargetBundle(NULL)
+    ->setLabel(new TranslatableMarkup('Revision parent'))
+    ->setDescription(new TranslatableMarkup('Indicates the parent revision ID.'))
+    ->setInternal(TRUE)
+    ->setTranslatable(FALSE)
+    ->setRevisionable(TRUE);
+
+  $field_storage_definitions['revision_merge_parent'] = BaseFieldDefinition::create('revision_reference')
+    ->setName('revision_merge_parent')
+    ->setTargetEntityTypeId('taxonomy_term')
+    ->setTargetBundle(NULL)
+    ->setLabel(new TranslatableMarkup('Revision merge parent'))
+    ->setDescription(new TranslatableMarkup('Indicates the merge parent revision ID.'))
+    ->setInternal(TRUE)
+    ->setTranslatable(FALSE)
+    ->setRevisionable(TRUE);
+
   $field_storage_definitions['revision_created'] = BaseFieldDefinition::create('created')
     ->setName('revision_created')
     ->setTargetEntityTypeId('taxonomy_term')
diff --git a/core/tests/Drupal/KernelTests/Core/Entity/ContentEntityCloneTest.php b/core/tests/Drupal/KernelTests/Core/Entity/ContentEntityCloneTest.php
index 8f08b272de..e462809278 100644
--- a/core/tests/Drupal/KernelTests/Core/Entity/ContentEntityCloneTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Entity/ContentEntityCloneTest.php
@@ -297,7 +297,7 @@ public function testEntityPropertiesModifications() {
     // Retrieve the entity properties.
     $reflection = new \ReflectionClass($entity);
     $properties = $reflection->getProperties(~\ReflectionProperty::IS_STATIC);
-    $translation_unique_properties = ['activeLangcode', 'translationInitialize', 'fieldDefinitions', 'languages', 'langcodeKey', 'defaultLangcode', 'defaultLangcodeKey', 'revisionTranslationAffectedKey', 'validated', 'validationRequired', 'entityTypeId', 'typedData', 'cacheContexts', 'cacheTags', 'cacheMaxAge', '_serviceIds', '_entityStorages'];
+    $translation_unique_properties = ['activeLangcode', 'translationInitialize', 'fieldDefinitions', 'languages', 'langcodeKey', 'defaultLangcode', 'defaultLangcodeKey', 'revisionTranslationAffectedKey', 'revisionParentKey', 'revisionMergeParentKey', 'validated', 'validationRequired', 'entityTypeId', 'typedData', 'cacheContexts', 'cacheTags', 'cacheMaxAge', '_serviceIds', '_entityStorages'];
 
     foreach ($properties as $property) {
       // Modify each entity property on the clone and assert that the change is
diff --git a/core/tests/Drupal/KernelTests/Core/Entity/EntityDefinitionUpdateTest.php b/core/tests/Drupal/KernelTests/Core/Entity/EntityDefinitionUpdateTest.php
index 8907b23f32..e43e14983c 100644
--- a/core/tests/Drupal/KernelTests/Core/Entity/EntityDefinitionUpdateTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Entity/EntityDefinitionUpdateTest.php
@@ -122,6 +122,8 @@ public function testEntityTypeUpdateWithoutData() {
         // The revision key is now defined, so the revision field needs to be
         // created.
         t('The %field_name field needs to be installed.', ['%field_name' => 'Revision ID']),
+        t('The %field_name field needs to be installed.', ['%field_name' => 'Revision parent']),
+        t('The %field_name field needs to be installed.', ['%field_name' => 'Revision merge parent']),
         t('The %field_name field needs to be installed.', ['%field_name' => 'Default revision']),
       ],
     ];
diff --git a/core/tests/Drupal/KernelTests/Core/Entity/EntityRevisionsTest.php b/core/tests/Drupal/KernelTests/Core/Entity/EntityRevisionsTest.php
index e5407fcc96..da7fa426cf 100644
--- a/core/tests/Drupal/KernelTests/Core/Entity/EntityRevisionsTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Entity/EntityRevisionsTest.php
@@ -14,6 +14,13 @@
  */
 class EntityRevisionsTest extends EntityKernelTestBase {
 
+  /**
+   * The storage of the test entity type.
+   *
+   * @var \Drupal\Core\Entity\RevisionableStorageInterface
+   */
+  protected $storage;
+
   /**
    * Modules to enable.
    *
@@ -33,6 +40,7 @@ protected function setUp() {
     parent::setUp();
 
     $this->installEntitySchema('entity_test_mulrev');
+    $this->storage = \Drupal::entityTypeManager()->getStorage('entity_test_mulrev');
   }
 
   /**
@@ -261,4 +269,131 @@ public function testIsLatestAffectedRevisionTranslation() {
     $this->assertTrue($en_revision->isLatestTranslationAffectedRevision());
   }
 
+  /**
+   * @covers ::getParentRevisionId
+   * @covers ::getMergeParentRevisionId
+   * @covers ::setParentRevisionId
+   * @covers ::setMergeParentRevisionId
+   */
+  public function testRevisionParents() {
+    $entity_field_manager = \Drupal::service('entity_field.manager');
+
+    // Check that the 'revision_parent' field is available by default for a
+    // revisionable entity type.
+    $base_field_definitions = $entity_field_manager->getBaseFieldDefinitions('entity_test_mulrev');
+    $this->assertArrayHasKey('revision_parent', $base_field_definitions);
+
+    // Check that the 'revision_parent' field is not available for a
+    // non-revisionable entity type
+    $base_field_definitions = $entity_field_manager->getBaseFieldDefinitions('entity_test_mul');
+    $this->assertArrayNotHasKey('revision_parent', $base_field_definitions);
+
+    // Check that the first revision of an entity does not have a parent.
+    /** @var \Drupal\Core\Entity\RevisionableInterface $revision_1 */
+    $revision_1 = $this->storage->create();
+    $revision_1->save();
+    $this->assertEmpty($revision_1->getParentRevisionId());
+    $this->assertEmpty($revision_1->getMergeParentRevisionId());
+
+    // Check that the revision parent field is populated automatically for
+    // subsequent revisions.
+    $revision_2 = $this->storage->createRevision($revision_1, TRUE);
+    $revision_2->save();
+    $this->assertEquals($revision_1->getRevisionId(), $revision_2->getParentRevisionId());
+    $this->assertEmpty($revision_2->getMergeParentRevisionId());
+
+    $revision_3 = $this->storage->createRevision($revision_2, FALSE);
+    $revision_3->save();
+    $this->assertEquals($revision_2->getRevisionId(), $revision_3->getParentRevisionId());
+    $this->assertEmpty($revision_3->getMergeParentRevisionId());
+
+    // Check that a new revision that doesn't start from the latest one gets the
+    // proper revision parent ID, which is the active revision of the branch.
+    $revision_4 = $this->storage->createRevision($revision_2, FALSE);
+    $revision_4->save();
+    $this->assertEquals($revision_3->getRevisionId(), $revision_4->getParentRevisionId());
+    $this->assertEmpty($revision_4->getMergeParentRevisionId());
+
+    // Check that we can assign the parent revision IDs manually.
+    $revision_5 = $this->storage->createRevision($revision_4, FALSE);
+    $revision_5->setParentRevisionId($revision_2->getRevisionId());
+    $revision_5->save();
+    $this->assertEquals($revision_2->getRevisionId(), $revision_5->getParentRevisionId());
+    $this->assertEmpty($revision_5->getMergeParentRevisionId());
+
+    $revision_6 = $this->storage->createRevision($revision_5, FALSE);
+    $revision_6->setParentRevisionId($revision_2->getRevisionId());
+    $revision_6->setMergeParentRevisionId($revision_3->getRevisionId());
+    $revision_6->save();
+    $this->assertEquals($revision_2->getRevisionId(), $revision_6->getParentRevisionId());
+    $this->assertEquals($revision_3->getRevisionId(), $revision_6->getMergeParentRevisionId());
+  }
+
+  /**
+   * @coversDefaultClass \Drupal\Core\Entity\Plugin\Validation\Constraint\ValidRevisionParentConstraintValidator
+   */
+  public function testRevisionParentsValidation() {
+    \Drupal::currentUser()->setAccount($this->createUser());
+
+    // Create an initial revision.
+    /** @var \Drupal\Core\Entity\RevisionableInterface $revision_1 */
+    $revision_1 = $this->storage->create();
+    $violations = $revision_1->validate();
+    $this->assertEmpty($violations);
+    $revision_1->save();
+
+    // Create a few more revisions which should have their parents assigned
+    // automatically.
+    $revision_2 = $this->storage->createRevision($revision_1);
+    $violations = $revision_2->validate();
+    $this->assertEmpty($violations);
+    $revision_2->save();
+
+    $revision_3 = $this->storage->createRevision($revision_2);
+    $violations = $revision_3->validate();
+    $this->assertEmpty($violations);
+    $revision_3->save();
+
+    $revision_4 = $this->storage->createRevision($revision_1);
+    $revision_4->setParentRevisionId($revision_1->getRevisionId());
+    $revision_4->setMergeParentRevisionId($revision_3->getRevisionId());
+    $violations = $revision_4->validate();
+    $this->assertEmpty($violations);
+    $revision_4->save();
+
+    // Try to change the parent of an existing revision.
+    $revision_3->setParentRevisionId($revision_4->getRevisionId());
+    $violations = $revision_3->validate();
+    $this->assertCount(1, $violations);
+    $this->assertEquals('The revision parents can not be changed for an existing revision.', $violations->get(0)->getMessage());
+    $this->assertEquals('revision_parent', $violations->get(0)->getPropertyPath());
+
+    // Try to change the merge parent of an existing revision.
+    $revision_4->setMergeParentRevisionId($revision_2->getRevisionId());
+    $violations = $revision_4->validate();
+    $this->assertCount(1, $violations);
+    $this->assertEquals('The revision parents can not be changed for an existing revision.', $violations->get(0)->getMessage());
+    $this->assertEquals('revision_merge_parent', $violations->get(0)->getPropertyPath());
+
+    // Try to use the same revision ID for both parents.
+    $revision_5 = $this->storage->createRevision($revision_3);
+    $revision_5->setParentRevisionId($revision_3->getRevisionId());
+    $revision_5->setMergeParentRevisionId($revision_3->getRevisionId());
+    $violations = $revision_5->validate();
+    $this->assertCount(1, $violations);
+    $this->assertEquals('The revision parents can not be the same.', $violations->get(0)->getMessage());
+    $this->assertEquals('revision_parent', $violations->get(0)->getPropertyPath());
+
+    // Try to use parents that don't exist.
+    $revision_6 = $this->storage->createRevision($revision_1);
+    $revision_6->setParentRevisionId(500);
+    $revision_6->setMergeParentRevisionId(501);
+    $violations = $revision_6->validate();
+    $this->assertCount(2, $violations);
+    $this->assertEquals('This revision (<em class="placeholder">500</em>) does not exist.', $violations->get(0)->getMessage());
+    $this->assertEquals('This revision (<em class="placeholder">501</em>) does not exist.', $violations->get(1)->getMessage());
+    $this->assertEquals('revision_parent', $violations->get(0)->getPropertyPath());
+    $this->assertEquals('revision_merge_parent', $violations->get(1)->getPropertyPath());
+  }
+
 }
diff --git a/core/tests/Drupal/Tests/Core/Entity/ContentEntityBaseUnitTest.php b/core/tests/Drupal/Tests/Core/Entity/ContentEntityBaseUnitTest.php
index 52cdd7621f..c65466ff59 100644
--- a/core/tests/Drupal/Tests/Core/Entity/ContentEntityBaseUnitTest.php
+++ b/core/tests/Drupal/Tests/Core/Entity/ContentEntityBaseUnitTest.php
@@ -142,7 +142,7 @@ protected function setUp() {
     $this->entityTypeId = $this->randomMachineName();
     $this->bundle = $this->randomMachineName();
 
-    $this->entityType = $this->getMock('\Drupal\Core\Entity\EntityTypeInterface');
+    $this->entityType = $this->getMock('\Drupal\Core\Entity\ContentEntityTypeInterface');
     $this->entityType->expects($this->any())
       ->method('getKeys')
       ->will($this->returnValue([
diff --git a/core/tests/Drupal/Tests/Core/Entity/KeyValueStore/KeyValueEntityStorageTest.php b/core/tests/Drupal/Tests/Core/Entity/KeyValueStore/KeyValueEntityStorageTest.php
index 0715ca7806..f89157ee9c 100644
--- a/core/tests/Drupal/Tests/Core/Entity/KeyValueStore/KeyValueEntityStorageTest.php
+++ b/core/tests/Drupal/Tests/Core/Entity/KeyValueStore/KeyValueEntityStorageTest.php
@@ -94,7 +94,7 @@ class KeyValueEntityStorageTest extends UnitTestCase {
    */
   protected function setUp() {
     parent::setUp();
-    $this->entityType = $this->getMock('Drupal\Core\Entity\EntityTypeInterface');
+    $this->entityType = $this->getMock('Drupal\Core\Entity\ContentEntityTypeInterface');
   }
 
   /**
diff --git a/core/tests/Drupal/Tests/Core/Entity/TypedData/EntityAdapterUnitTest.php b/core/tests/Drupal/Tests/Core/Entity/TypedData/EntityAdapterUnitTest.php
index 2881f39a5a..5b9e1c7d29 100644
--- a/core/tests/Drupal/Tests/Core/Entity/TypedData/EntityAdapterUnitTest.php
+++ b/core/tests/Drupal/Tests/Core/Entity/TypedData/EntityAdapterUnitTest.php
@@ -138,7 +138,7 @@ protected function setUp() {
     $this->entityTypeId = $this->randomMachineName();
     $this->bundle = $this->randomMachineName();
 
-    $this->entityType = $this->getMock('\Drupal\Core\Entity\EntityTypeInterface');
+    $this->entityType = $this->getMock('\Drupal\Core\Entity\ContentEntityTypeInterface');
     $this->entityType->expects($this->any())
       ->method('getKeys')
       ->will($this->returnValue([
